{"version":3,"names":["computed","signal","batch","getNamespaceFromProxy","getScope","setNamespace","resetNamespace","withScope","NO_SCOPE","PropSignal","constructor","owner","computedsByScope","WeakMap","setValue","value","update","setGetter","getter","get","setPendingGetter","pendingGetter","queueMicrotask","consolidateGetter","undefined","getComputed","scope","valueSignal","getterSignal","has","callback","call","set","peek"],"sources":["@wordpress/interactivity/src/proxies/signals.ts"],"sourcesContent":["/**\n * External dependencies\n */\nimport {\n\tcomputed,\n\tsignal,\n\tbatch,\n\ttype Signal,\n\ttype ReadonlySignal,\n} from '@preact/signals';\n\n/**\n * Internal dependencies\n */\nimport { getNamespaceFromProxy } from './registry';\nimport { getScope } from '../scopes';\nimport { setNamespace, resetNamespace } from '../namespaces';\nimport { withScope } from '../utils';\n\n/**\n * Identifier for property computeds not associated to any scope.\n */\nconst NO_SCOPE = {};\n\n/**\n * Structure that manages reactivity for a property in a state object. It uses\n * signals to keep track of property value or getter modifications.\n */\nexport class PropSignal {\n\t/**\n\t * Proxy that holds the property this PropSignal is associated with.\n\t */\n\tprivate owner: object;\n\n\t/**\n\t * Relation of computeds by scope. These computeds are read-only signals\n\t * that depend on whether the property is a value or a getter and,\n\t * therefore, can return different values depending on the scope in which\n\t * the getter is accessed.\n\t */\n\tprivate computedsByScope: WeakMap< WeakKey, ReadonlySignal >;\n\n\t/**\n\t * Signal with the value assigned to the related property.\n\t */\n\tprivate valueSignal?: Signal;\n\n\t/**\n\t * Signal with the getter assigned to the related property.\n\t */\n\tprivate getterSignal?: Signal< ( () => any ) | undefined >;\n\n\t/**\n\t * Pending getter to be consolidated.\n\t */\n\tprivate pendingGetter?: () => any;\n\n\t/**\n\t * Structure that manages reactivity for a property in a state object, using\n\t * signals to keep track of property value or getter modifications.\n\t *\n\t * @param owner Proxy that holds the property this instance is associated\n\t *              with.\n\t */\n\tconstructor( owner: object ) {\n\t\tthis.owner = owner;\n\t\tthis.computedsByScope = new WeakMap();\n\t}\n\n\t/**\n\t * Changes the internal value. If a getter was set before, it is set to\n\t * `undefined`.\n\t *\n\t * @param value New value.\n\t */\n\tpublic setValue( value: unknown ) {\n\t\tthis.update( { value } );\n\t}\n\n\t/**\n\t * Changes the internal getter. If a value was set before, it is set to\n\t * `undefined`.\n\t *\n\t * @param getter New getter.\n\t */\n\tpublic setGetter( getter: () => any ) {\n\t\tthis.update( { get: getter } );\n\t}\n\n\t/**\n\t * Changes the internal getter asynchronously.\n\t *\n\t * The update is made in a microtask, which prevents issues with getters\n\t * accessing the state, and ensures the update occurs before any render.\n\t *\n\t * @param getter New getter.\n\t */\n\tpublic setPendingGetter( getter: () => any ) {\n\t\tthis.pendingGetter = getter;\n\t\tqueueMicrotask( () => this.consolidateGetter() );\n\t}\n\n\t/**\n\t * Consolidate the pending value of the getter.\n\t */\n\tprivate consolidateGetter() {\n\t\tconst getter = this.pendingGetter;\n\t\tif ( getter ) {\n\t\t\tthis.pendingGetter = undefined;\n\t\t\tthis.update( { get: getter } );\n\t\t}\n\t}\n\n\t/**\n\t * Returns the computed that holds the result of evaluating the prop in the\n\t * current scope.\n\t *\n\t * These computeds are read-only signals that depend on whether the property\n\t * is a value or a getter and, therefore, can return different values\n\t * depending on the scope in which the getter is accessed.\n\t *\n\t * @return Computed that depends on the scope.\n\t */\n\tpublic getComputed(): ReadonlySignal {\n\t\tconst scope = getScope() || NO_SCOPE;\n\n\t\tif ( ! this.valueSignal && ! this.getterSignal ) {\n\t\t\tthis.update( {} );\n\t\t}\n\n\t\t/*\n\t\t * If there is any pending getter, consolidate it first. This\n\t\t * could happen if a getter is accessed synchronously after\n\t\t * being set with `store()`.\n\t\t */\n\t\tif ( this.pendingGetter ) {\n\t\t\tthis.consolidateGetter();\n\t\t}\n\n\t\tif ( ! this.computedsByScope.has( scope ) ) {\n\t\t\tconst callback = () => {\n\t\t\t\tconst getter = this.getterSignal?.value;\n\t\t\t\treturn getter\n\t\t\t\t\t? getter.call( this.owner )\n\t\t\t\t\t: this.valueSignal?.value;\n\t\t\t};\n\n\t\t\tsetNamespace( getNamespaceFromProxy( this.owner ) );\n\t\t\tthis.computedsByScope.set(\n\t\t\t\tscope,\n\t\t\t\tcomputed( withScope( callback ) )\n\t\t\t);\n\t\t\tresetNamespace();\n\t\t}\n\n\t\treturn this.computedsByScope.get( scope )!;\n\t}\n\n\t/**\n\t *  Updates the internal signals for the value and the getter of the\n\t *  corresponding prop.\n\t *\n\t * @param param0\n\t * @param param0.get   New getter.\n\t * @param param0.value New value.\n\t */\n\tprivate update( { get, value }: { get?: () => any; value?: unknown } ) {\n\t\tif ( ! this.valueSignal ) {\n\t\t\tthis.valueSignal = signal( value );\n\t\t\tthis.getterSignal = signal( get );\n\t\t} else if (\n\t\t\tvalue !== this.valueSignal.peek() ||\n\t\t\tget !== this.getterSignal!.peek()\n\t\t) {\n\t\t\tbatch( () => {\n\t\t\t\tthis.valueSignal!.value = value;\n\t\t\t\tthis.getterSignal!.value = get;\n\t\t\t} );\n\t\t}\n\t}\n}\n"],"mappings":"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","ignoreList":[]}